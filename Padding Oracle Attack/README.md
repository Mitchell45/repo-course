CBC模式的全称是Cipher Block Chaining模式，即密文分组链接模式，之所以叫这个名字，是因为密文分组像链条一样相互连接在一起。在CBC模式中，首先将明文分组与前一个密文分组进行异或运算，然后再进行加密。

填充提示攻击是一种利用分组密码中填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充数据进行少许改变。由于接收者（或者说服务器）在无法正确解密时会返回一个错误信息，攻击者通过这一错误消息就可以获得与明文相关的信息。（这一攻击并不仅限于CBC模式，还适用于所有需要进行分组填充的模式）。

填充提示攻击成立有两个重要前提：
1.攻击者能够获得密文，以及附带在密文前面的iv（初始化向量）；
2.攻击者能够出发密文的解密过程，且能够知道密文的解密结果。

明文分组和填充就是Padding Oracle Attack的根源所在，但是这些需要⼀个前提，那就是应用程序对异常的处理。当提交的加密后的数据中出现错误的填充信息时，不够健壮的应用程序解密时报错，直接抛出"填充错误"异常信息(错误信息在不同的应用中是不同的体现，一般是报500错误)。


我们知道，AES-128-CBC分组密码的分组为：以16字节为一组（8bit/字节），即32个十六进制数为一组。

在开始攻击函数之前，需要一些准备工作：

1.  对截获的目标密文进行切片处理，得到16字节一组的iv和多段密文数据；

2.  Import解密服务器，构建访问测试函数test( )，服务器反馈200时，表示输入满足PKCS#7填充规则，返回True。

接下来，开始攻击函数的部分：（该部分只介绍原理和实现思路）

在AES-128-CBC分组密码中，iv\|\|c1\|\|c2\|\|c3的解密流程如下：

$$
iv \lor dec(c1)= m1
\\iv \lor dec(c2)= m2
\\iv \lor dec(c3)= m3
$$
其中的iv、c1、c2、c3我们是已知的，所以如果要求m1、m2、m3，那么我们只需要求出 dec（c1）、dec（c2）、dec（c3）。

那么我们如何求解dec（c）呢？根据实验指导，我们总结的求解思路如下：

我们以iv\|\|c为例，令a=dec（c），显然a也是16字节。为了求a，我们引入了16字节的虚拟分组r，企图借助r\|\|c不断做test( )时的反馈来推断出a。

①从r的最后一个字节r~n~开始，我们对它进行遍历（从0-\>255）,直到r\|\|c的反馈结果为True，那么r的该字节满足填充规则，即
$$
r_n\lor a_n~=0x01
$$
显然$a_n=r_n \lor 0x01$

②然后我们将$r_n$设置为a~n~OR 0x02，即我们将上一步的填充规则从0x01改为了0x02；

③因为r~n~已经被我们设为了满足0x02规则的字节，所以只需像r~n~那样，对r~n-1~进行遍历（从0-\>255）,直到r\|\|c的反馈结果为True，满足填充规则（显然$a_{n-1}=r\lor 0x02$）；

剩下的a~n-2~、a~n-3~、\...，只需要重复类似②③的操作，通过修改填充规则、再找到满足填充规则的r、r和填充规则异或，三步走的策略，来得到。

最后将a（dec(c)）和 iv 异或，即可得到目标明文。

